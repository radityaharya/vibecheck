import type { NextApiRequest, NextApiResponse } from "next";
import { createServerSupabaseClient } from "@supabase/auth-helpers-nextjs";
import { PrismaClient } from "@prisma/client";
import SpotifyWebApi from "spotify-web-api-node";
import getAccessToken from "~/lib/supabase/getAccessToken";
import { log } from "next-axiom";

const prisma = new PrismaClient();

type Room = {
  name: string;
  slug: string;
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const supabase = createServerSupabaseClient({ req, res });
  const {
    data: { session },
  } = await supabase.auth.getSession();

  const userId = session?.user?.id as string;

  if (!userId) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  // TODO: change to req.body

  const { slug, name } = req.query;

  const data: Room = {
    name: name as string,
    slug: slug as string,
  };

  if (!data) {
    log.error("Failed registering room: no data");
    return res.status(400).json({ error: "Required params: name, slug" });
  }

  const room = await prisma.room.findUnique({
    where: {
      slug: data.slug,
    },
  });

  if (room) {
    log.error("Failed registering room: slug already exists");
    return res.status(400).json({ error: "slug already exists" });
  }

  let newRoom = await prisma.room
    .create({
      data: {
        name: data.name,
        slug: data.slug,
        roomMasterId: userId,
      },
    })
    .catch((err) => {
      log.error(`Failed registering room: ${err as string}`);
      return res.status(500).json({
        error: err as string,
      });
    });

  const spotifyToken = await getAccessToken(userId);

  if (!spotifyToken) {
    return res.status(500).json({
      error: "No Spotify token found",
    });
  }

  const spt = new SpotifyWebApi({
    accessToken: spotifyToken,
  });

  // TODO: separate this into a separate function
  const TempPlaylist = await spt.searchPlaylists(newRoom?.id as string, {
    limit: 1,
  });

  if (TempPlaylist?.body?.playlists?.total === 0) {
    log.info(`Creating new temp playlist for ${newRoom?.name as string}`);

    if (!newRoom) {
      return res.status(500).json({
        error: "Error creating temp playlist",
      });
    }

    const description =
      "Autogenerated By Vibecheck Please do not delete or modify this playlist";

    const newTempPlaylist = await spt.createPlaylist(newRoom?.name, {
      description,
      "public": false as boolean,
    });

    newRoom = await prisma.room.update({
      where: {
        id: newRoom?.id,
      },
      data: {
        tempPlaylistId: newTempPlaylist.body.id,
      },
    });
  } else {
    log.info(`Temp playlist already exists for ${newRoom?.name as string}`);
  }

  await prisma.queue
    .create({
      data: {
        roomId: newRoom?.id as string,
      },
    })
    .catch((err) => {
      log.error(
        `Failed creating queue for ${newRoom?.name as string}: ${err as string}`
      );
      return res.status(500).json({
        error: err as string,
      });
    });

  log.info(`Successfully registered room ${newRoom?.name as string}`);
  return res.status(200).json({ room: newRoom });
}
