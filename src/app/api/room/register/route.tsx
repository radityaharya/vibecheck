import { createRouteHandlerClient } from "@supabase/auth-helpers-nextjs";
import { prisma } from "~/lib/prisma/client";
import SpotifyWebApi from "spotify-web-api-node";
import getAccessToken from "~/lib/supabase/getAccessToken";
import { log } from "next-axiom";
import { cookies } from "next/headers";
import { NextRequest, NextResponse } from "next/server";

type Room = {
  name: string;
  slug: string;
};

export async function GET(req: NextRequest) {
  const supabase = createRouteHandlerClient({ cookies });
  const {
    data: { user },
  } = await supabase.auth.getUser();

  const userId = user?.id as string;

  if (!userId) {
    return NextResponse.json({ error: "no user" }, { status: 400 });
  }

  // TODO: change to req.body

  const slug = req.nextUrl.searchParams.get("slug");
  const name = req.nextUrl.searchParams.get("name");

  const data: Room = {
    name: name as string,
    slug: slug as string,
  };

  if (!data) {
    log.error("Failed registering room: no data");
    return NextResponse.json({ error: "no data" }, { status: 400 });
  }

  const room = await prisma.room.findUnique({
    where: {
      slug: data.slug,
    },
  });

  if (room) {
    log.error("Failed registering room: slug already exists");
    return NextResponse.json({ error: "slug already exists" }, { status: 400 });
  }

  const spotifyToken = await getAccessToken(userId);

  if (!spotifyToken) {
    return NextResponse.json({ error: "no spotify token" }, { status: 400 });
  }

  let newRoom = await prisma.room
    .create({
      data: {
        name: data.name,
        slug: data.slug,
        roomMasterId: userId,
      },
    })
    .catch((err) => {
      log.error(`Failed registering room: ${err as string}`);
      throw new Error(err as string);
    });

  if (!newRoom) {
    log.error("Failed registering room: no room");
    return NextResponse.json({ error: "no room" }, { status: 500 });
  }

  const spt = new SpotifyWebApi({
    accessToken: spotifyToken,
  });

  // TODO: separate this into a separate function
  const TempPlaylist = await spt.searchPlaylists(newRoom?.id, {
    limit: 1,
  });

  if (TempPlaylist?.body?.playlists?.total === 0) {
    log.info(`Creating new temp playlist for ${newRoom?.name}`);

    if (!newRoom) {
      return NextResponse.json(
        { error: "Failed creating temp playlist: no room" },
        { status: 500 }
      );
    }

    const description =
      "Autogenerated By Vibecheck Please do not delete or modify this playlist";

    const newTempPlaylist = await spt.createPlaylist(newRoom?.name, {
      description,
      "public": false as boolean,
    });

    newRoom = await prisma.room.update({
      where: {
        id: newRoom?.id,
      },
      data: {
        tempPlaylistId: newTempPlaylist.body.id,
      },
    });
  } else {
    log.info(`Temp playlist already exists for ${newRoom?.name}`);
  }

  await prisma.queue
    .create({
      data: {
        roomId: newRoom?.id,
      },
    })
    .catch((err) => {
      log.error(`Failed creating queue for ${newRoom?.name}: ${err as string}`);
      return NextResponse.json(
        { error: `Failed creating queue: ${err as string}` },
        { status: 500 }
      );
    });

  log.info(`Successfully registered room ${newRoom?.name}`);
  return NextResponse.redirect(`${req.nextUrl.origin}/room/${newRoom?.slug}`);
}
